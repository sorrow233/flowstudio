import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { useAuth } from '@/contexts/AuthContext';
import * as firestoreApi from '../api/firestore';
import * as localApi from '../api/local';
import { STAGES, validateForNextStage, getNextStage, generatePastelColor } from '../domain';

export const useProjects = () => {
    const { currentUser, isGuest } = useAuth();
    const queryClient = useQueryClient();
    const userId = currentUser?.uid;

    // Select API based on auth state
    const api = (currentUser && !isGuest) ? firestoreApi : localApi;
    const queryKey = ['projects', (currentUser && !isGuest) ? userId : 'guest'];

    // --- Queries ---

    const projectsQuery = useQuery({
        queryKey,
        queryFn: () => api.fetchProjects(userId),
        // Only run if we have a user or we are in guest mode
        enabled: isGuest || !!userId,
        // When switching users, don't keep previous data
        staleTime: 1000 * 60 * 5,
    });

    // --- Mutations ---

    const addProjectMutation = useMutation({
        mutationFn: (project) => api.addProject(userId, project),
        onSuccess: (newProject) => {
            // Optimistic-like update via cache manipulation
            queryClient.setQueryData(queryKey, (oldData) => {
                if (!oldData) return [newProject];
                return [...oldData, newProject];
            });
        },
    });

    const updateProjectMutation = useMutation({
        mutationFn: ({ id, updates }) => api.updateProject(userId, id, updates),
        onSuccess: (_, { id, updates }) => {
            queryClient.setQueryData(queryKey, (oldData) => {
                if (!oldData) return [];
                return oldData.map((project) =>
                    project.id === id ? { ...project, ...updates } : project
                );
            });
        },
    });

    const deleteProjectMutation = useMutation({
        mutationFn: (id) => api.deleteProject(userId, id),
        onSuccess: (_, id) => {
            queryClient.setQueryData(queryKey, (oldData) => {
                if (!oldData) return [];
                return oldData.filter((project) => project.id !== id);
            });
        },
    });

    return {
        // Data
        projects: projectsQuery.data || [],
        isLoading: projectsQuery.isLoading,
        error: projectsQuery.error,

        // Actions
        addProject: addProjectMutation.mutateAsync,
        updateProject: updateProjectMutation.mutateAsync,
        deleteProject: deleteProjectMutation.mutateAsync,

        // Metadata
        isGuest,

        // Convenience Methods (Legacy Support & Business Logic)
        validateForNextStage,

        moveItemNext: async (id) => {
            const project = projectsQuery.data?.find(p => p.id === id);
            if (!project) return;

            const nextStage = getNextStage(project.stage);
            if (!nextStage) return;

            const validation = validateForNextStage(project, nextStage);
            if (!validation.valid) throw new Error(validation.message);

            return updateProjectMutation.mutateAsync({ id, updates: { stage: nextStage } });
        },

        moveItemToStage: async (id, newStage) => {
            const project = projectsQuery.data?.find(p => p.id === id);
            if (!project) return { success: false, message: 'Project not found' };

            const validation = validateForNextStage(project, newStage);
            if (!validation.valid) return { success: false, message: validation.message };

            await updateProjectMutation.mutateAsync({ id, updates: { stage: newStage } });
            return { success: true };
        },

        toggleArchive: async (id) => {
            const project = projectsQuery.data?.find(p => p.id === id);
            if (!project) return;
            return updateProjectMutation.mutateAsync({ id, updates: { archived: !project.archived } });
        },

        // Add with defaults
        addItem: async (stage = STAGES.INSPIRATION, formData = {}) => {
            const newItem = {
                name: formData.name || '',
                link: formData.link || '',
                goal: formData.goal || '',
                priority: formData.priority || 'medium', // low, medium, high
                deadline: formData.deadline || null,
                color: generatePastelColor(),
                stage: stage,
                archived: false,
                // ID is generated by API (uuid in local, docId in firestore)
                // Wait, APIs expect ID generated? 
                // Local API in previous step expected complete object?
                // Let's check api/firestore.js. It says "addProject(userId, project)".
                // And LocalStorage api implementation: "const nextItems = [...items, project];"
                // So we need to generate ID here if not provided?
                // Firestore ref requires ID: `doc(db, ..., project.id)`
                // So yes, we need to generate ID here.
                id: crypto.randomUUID(),
                createdAt: new Date().toISOString(),
                updatedAt: new Date().toISOString()
            };
            return addProjectMutation.mutateAsync(newItem);
        }
